// Generated by CoffeeScript 1.4.0
(function() {
  var GraphJS, clone, typeIsArray, update, _items, _list, _sum,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  GraphJS = (typeof exports !== "undefined" && exports !== null) && exports || (GraphJS = {});

  update = function(object, attr) {
    var key, val, _results;
    _results = [];
    for (key in attr) {
      val = attr[key];
      _results.push(object[key] = val);
    }
    return _results;
  };

  clone = function(obj) {
    var flags, key, newInstance;
    if (!(obj != null) || typeof obj !== 'object') {
      return obj;
    }
    if (obj instanceof Date) {
      return new Date(obj.getTime());
    }
    if (obj instanceof RegExp) {
      flags = '';
      if (obj.global != null) {
        flags += 'g';
      }
      if (obj.ignoreCase != null) {
        flags += 'i';
      }
      if (obj.multiline != null) {
        flags += 'm';
      }
      if (obj.sticky != null) {
        flags += 'y';
      }
      return new RegExp(obj.source, flags);
    }
    newInstance = new obj.constructor();
    for (key in obj) {
      newInstance[key] = clone(obj[key]);
    }
    return newInstance;
  };

  typeIsArray = Array.isArray || function(value) {
    return {}.toString.call(value) === '[object Array]';
  };

  _items = function(dict) {
    var key, val;
    return (function() {
      var _results;
      _results = [];
      for (key in dict) {
        val = dict[key];
        _results.push([key, val]);
      }
      return _results;
    })();
  };

  _sum = function(nums) {
    return nums.reduce(function(a, b) {
      return a + b;
    });
  };

  _list = function(iterable) {
    if (typeIsArray(iterable)) {
      return iterable;
    } else {
      return Object.getOwnPropertyNames(iterable);
    }
  };

  GraphJS.DiGraph = (function(_super) {

    __extends(DiGraph, _super);

    function DiGraph(data, attr) {
      if (data == null) {
        data = null;
      }
      if (attr == null) {
        attr = {};
      }
      this.graph = {};
      this.node = {};
      this.adj = {};
      this.pred = {};
      this.succ = this.adj;
      if (data === !null) {
        convert.to_graphjs_graph(data, this);
      }
      update(this.graph, attr);
      this.edge = this.adj;
    }

    DiGraph.prototype.add_node = function(n, attr_dict, attr) {
      if (attr_dict == null) {
        attr_dict = null;
      }
      if (attr == null) {
        attr = {};
      }
      if (attr_dict === null) {
        attr_dict = attr;
      } else {
        try {
          update(attr_dict, attr);
        } catch (error) {
          console.log("attr_dict argument must be a dictionary");
        }
      }
      if (!(n in this.node)) {
        this.succ[n] = {};
        this.pred[n] = {};
        return this.node[n] = attr_dict;
      } else {
        return update(this.node[n], attr_dict);
      }
    };

    DiGraph.prototype.add_nodes_from = function(nodes, attr) {
      var i, n, ndict, newdict, nn, olddict, pair, _results, _results1;
      if (attr == null) {
        attr = {};
      }
      if (typeIsArray(nodes)) {
        _results = [];
        for (i in nodes) {
          pair = nodes[i];
          n = pair[0];
          if (!(n in this.succ)) {
            this.succ[n] = {};
            this.pred[n] = {};
            _results.push(this.node[n] = clone(attr));
          } else {
            _results.push(update(this.node[n], attr));
          }
        }
        return _results;
      } else {
        _results1 = [];
        for (nn in nodes) {
          ndict = nodes[nn];
          if (!(nn in this.succ)) {
            this.succ[nn] = {};
            this.pred[nn] = {};
            newdict = clone(attr);
            update(newdict, ndict);
            _results1.push(this.node[nn] = newdict);
          } else {
            olddict = this.node[nn];
            update(olddict, attr);
            _results1.push(update(olddict, ndict));
          }
        }
        return _results1;
      }
    };

    DiGraph.prototype.remove_node = function(n) {
      var i, u, _i, _len, _ref;
      if (n in self.succ) {
        delete this.succ[n];
        delete this.node[n];
      } else {
        console.log('The node %s is not in the digraph', n);
      }
      for (i in nbrs) {
        u = nbrs[i];
        delete this.pred[u][n];
      }
      delete this.succ[n];
      _ref = this.pred[n];
      for (u = _i = 0, _len = _ref.length; _i < _len; u = ++_i) {
        i = _ref[u];
        delete this.succ[u][n];
      }
      return delete this.pred[n];
    };

    DiGraph.prototype.remove_nodes_from = function(nbunch) {
      var i, n, succs, u, _results;
      _results = [];
      for (i in nbunch) {
        n = nbunch[i];
        succs = this.succ[n];
        delete this.node[n];
        for (u in succs) {
          delete this.pred[u][n];
        }
        delete this.succ[n];
        for (u in this.pred[n]) {
          delete this.succ[u][n];
        }
        _results.push(delete this.pred[n]);
      }
      return _results;
    };

    DiGraph.prototype.add_edge = function(u, v, attr_dict, attr) {
      var datadict;
      if (attr_dict == null) {
        attr_dict = null;
      }
      if (attr == null) {
        attr = {};
      }
      if (attr_dict === null) {
        attr_dict = attr;
      } else {
        try {
          update(attr_dict(attr));
        } catch (error) {
          console.log("The attr_dict argument must be a dictionary");
        }
      }
      if (!(u in this.succ)) {
        this.succ[u] = {};
        this.pred[u] = {};
        this.node[u] = {};
      }
      if (!(v in this.succ)) {
        this.succ[v] = {};
        this.pred[v] = {};
        this.node[v] = {};
      }
      datadict = this.adj[u][v] || {};
      update(datadict(attr_dict));
      this.succ[u][v] = datadict;
      return this.pred[v][u] = datadict;
    };

    DiGraph.prototype.add_edges_from = function(ebunch, attr_dict, attr) {
      var datadict, dd, e, i, u, v, _results;
      if (attr_dict == null) {
        attr_dict = null;
      }
      if (attr == null) {
        attr = {};
      }
      /*
          Add all edges in ebunch
          i.e. [['A','B'],[1,'2'],['node','foobar',{'key':'value'}]]
      */

      if (attr_dict === null) {
        attr_dict = attr;
      } else {
        try {
          update(attr_dict(attr));
        } catch (error) {
          console.log("attr_dict argument must be a dictionary.");
        }
      }
      _results = [];
      for (i in ebunch) {
        e = ebunch[i];
        switch (e.length) {
          case 3:
            u = e[0];
            v = e[1];
            dd = e[2];
            break;
          case 2:
            u = e[0];
            v = e[1];
            dd = {};
            break;
          default:
            console.log("Edge tuple %s must be a 2-array or a 3-array", e);
        }
        if (!(u in this.succ)) {
          this.succ[u] = {};
          this.pred[u] = {};
          this.node[u] = {};
        }
        if (!(v in this.succ)) {
          this.succ[v] = {};
          this.pred[v] = {};
          this.node[v] = {};
        }
        datadict = this.adj[u][v] || {};
        update(datadict, attr_dict);
        update(datadict, dd);
        this.succ[u][v] = datadict;
        _results.push(this.pred[v][u] = datadict);
      }
      return _results;
    };

    DiGraph.prototype.remove_edge = function(u, v) {
      if (this.succ[u][v]) {
        delete this.succ[u][v];
        return delete this.pred[v][i];
      } else {
        return console.log("The edge %s-%s is not in the graph", u, v);
      }
    };

    DiGraph.prototype.remove_edges_from = function(ebunch) {
      var e, i, u, v, _results;
      _results = [];
      for (i in ebunch) {
        e = ebunch[i];
        u = e[0];
        v = e[1];
        if (u in this.succ && v in this.succ[u]) {
          delete this.succ[u][v];
          _results.push(delete this.pred[v][u]);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    DiGraph.prototype.has_successor = function(u, v) {
      return u in self.succ && v in self.succ[u];
    };

    DiGraph.prototype.has_predecessor = function(u, v) {
      return u in self.pred && v in self.pred[u];
    };

    DiGraph.prototype.successors = function(n) {
      return _list(this.succ[n]);
    };

    def({
      predecessors: function(n) {
        return _list(this.pred[n]);
      }
    });

    DiGraph.prototype.neighbors = DiGraph.successors;

    DiGraph.prototype.neighbors_iter = DiGraph.successors_iter;

    return DiGraph;

  })(GraphJS.Graph);

  GraphJS.Graph = (function() {

    function Graph(data, attr) {
      if (data == null) {
        data = null;
      }
      if (attr == null) {
        attr = {};
      }
      this.graph = {};
      this.node = {};
      this.adj = {};
      if (data !== null) {
        convert.to_graphjs_graph(data, this);
      }
      update(this.graph, attr);
      this.edge = this.adj;
      return this;
    }

    Graph.prototype.add_node = function(n, attr_dict, attr) {
      if (attr_dict == null) {
        attr_dict = null;
      }
      if (attr == null) {
        attr = {};
      }
      if (attr_dict === null) {
        attr_dict = attr;
      } else {
        try {
          update(attr_dict, attr);
        } catch (error) {
          console.log("attr_dict argument must be a dictionary");
        }
      }
      if (!(n in this.node)) {
        this.adj[n] = {};
        return this.node[n] = attr_dict;
      } else {
        return update(this.node[n], attr_dict);
      }
    };

    Graph.prototype.add_nodes_from = function(nodes, attr) {
      var i, ndict, newdict, nn, olddict, pair, _results, _results1;
      if (attr == null) {
        attr = {};
      }
      /*
          adds multiple nodes
          Due to JavaScript's different comprehension style, I was forced to implement this differently
          than NetworkX
      
          Can take two formats:
      
          array of
          [[node,dict],[node,dict],[node,dict]] pairs (faking tuples)
      
          or
      
          {
            'node':dict,
            'node':dict,
            etc.
          }
      */

      if (typeIsArray(nodes)) {
        _results = [];
        for (i in nodes) {
          pair = nodes[i];
          if (!(pair[0] in this.node)) {
            this.adj[pair[0]] = {};
            newdict = clone(attr);
            update(newdict, pair[1]);
            _results.push(this.node[pair[0]] = newdict);
          } else {
            olddict = this.node[pair[0]];
            update(olddict, attr);
            _results.push(update(olddict, pair[1]));
          }
        }
        return _results;
      } else {
        _results1 = [];
        for (nn in nodes) {
          ndict = nodes[nn];
          if (!(nn in this.node)) {
            this.adj[nn] = {};
            newdict = clone(attr);
            update(newdict, ndict);
            _results1.push(this.node[nn] = newdict);
          } else {
            olddict = this.node[nn];
            update(olddict, attr);
            _results1.push(update(olddict, ndict));
          }
        }
        return _results1;
      }
    };

    Graph.prototype.remove_node = function(n) {
      /*
            removes node n
      */

      var adj, i, key, nbrs, u;
      adj = this.adj;
      try {
        nbrs = (function() {
          var _results;
          _results = [];
          for (key in adj[n]) {
            _results.push(key);
          }
          return _results;
        })();
        delete this.node[n];
        for (i in nbrs) {
          u = nbrs[i];
          delete adj[u][n];
        }
        return delete adj[n];
      } catch (error) {
        return console.log("The node %s is not in the graph.", n);
      }
    };

    Graph.prototype.remove_nodes_from = function(nodes) {
      /*
            removes multiple nodes
      
            nodes is presumed to be an array
      */

      var adj, i, n, u, _results;
      adj = this.adj;
      _results = [];
      for (i in nodes) {
        n = nodes[i];
        try {
          delete this.node[n];
          for (u in adj[n]) {
            delete adj[u][n];
          }
          _results.push(delete adj[n]);
        } catch (error) {
          continue;
        }
      }
      return _results;
    };

    Graph.prototype.nodes = function(data) {
      var node, node_data, _ref, _results, _results1;
      if (data == null) {
        data = false;
      }
      if (data) {
        _ref = this.node;
        _results = [];
        for (node in _ref) {
          node_data = _ref[node];
          _results.push([node, node_data]);
        }
        return _results;
      } else {
        _results1 = [];
        for (node in this.node) {
          _results1.push(node);
        }
        return _results1;
      }
    };

    Graph.prototype.number_of_nodes = function() {
      return (_list(this.node)).length;
    };

    Graph.prototype.order = function() {
      return this.number_of_nodes(this.node);
    };

    Graph.prototype.has_node = function(n) {
      return n in this.node;
    };

    Graph.prototype.add_edge = function(u, v, attr_dict, attr) {
      var datadict;
      if (attr_dict == null) {
        attr_dict = null;
      }
      if (attr == null) {
        attr = {};
      }
      /*
          adds edge between u, v
      */

      if (attr_dict === null) {
        attr_dict = attr;
      } else {
        try {
          update(attr_dict(attr));
        } catch (error) {
          console.log("attr_dict argument must be a dictionary.");
        }
      }
      if (!(u in this.node)) {
        this.adj[u] = {};
        this.node[u] = {};
      }
      if (!(v in this.node)) {
        this.adj[v] = {};
        this.node[v] = {};
      }
      datadict = this.adj[u][v] || {};
      update(datadict, attr_dict);
      this.adj[u][v] = datadict;
      return this.adj[v][u] = datadict;
    };

    Graph.prototype.add_edges_from = function(ebunch, attr_dict, attr) {
      var datadict, dd, e, i, u, v, _results;
      if (attr_dict == null) {
        attr_dict = null;
      }
      if (attr == null) {
        attr = {};
      }
      /*
          Add all edges in ebunch
          i.e. [['A','B'],[1,'2'],['node','foobar',{'key':'value'}]]
      */

      if (attr_dict === null) {
        attr_dict = attr;
      } else {
        try {
          update(attr_dict(attr));
        } catch (error) {
          console.log("attr_dict argument must be a dictionary.");
        }
      }
      _results = [];
      for (i in ebunch) {
        e = ebunch[i];
        switch (e.length) {
          case 3:
            u = e[0];
            v = e[1];
            dd = e[2];
            break;
          case 2:
            u = e[0];
            v = e[1];
            dd = {};
            break;
          default:
            console.log("Edge tuple %s must be a 2-array or a 3-array", e);
        }
        if (!(u in this.node)) {
          this.adj[u] = {};
          this.node[u] = {};
        }
        if (!(v in this.node)) {
          this.adj[v] = {};
          this.node[v] = {};
        }
        datadict = this.adj[u][v] || {};
        update(datadict, attr_dict);
        update(datadict, dd);
        this.adj[u][v] = datadict;
        _results.push(this.adj[v][u] = datadict);
      }
      return _results;
    };

    Graph.prototype.add_weighted_edges_from = function(ebunch, weight, attr) {
      var e, i;
      if (weight == null) {
        weight = 'weight';
      }
      if (attr == null) {
        attr = {};
      }
      /*
          add all edges in ebunch as weighted edges with specified weights
      */

      return this.add_edges_from((function() {
        var _results;
        _results = [];
        for (i in ebunch) {
          e = ebunch[i];
          _results.push([
            e[0], e[1], {
              weight: e[2]
            }
          ]);
        }
        return _results;
      })(), null, attr);
    };

    Graph.prototype.remove_edge = function(u, v) {
      if (this.adj[u] && this.adj[u][v]) {
        delete this.adj[u][v];
        if (u === !v) {
          return del(this.adj[v][u]);
        }
      } else {
        return console.log("The edge %s-%s is not in the graph", u, v);
      }
    };

    Graph.prototype.has_edge = function(u, v) {
      return v in this.adj[u];
    };

    Graph.prototype.neighbors = function(n) {
      /*
          returns list of nodes connected to node n
      */

      var key;
      try {
        return (function() {
          var _results;
          _results = [];
          for (key in this.adj[n]) {
            _results.push(key);
          }
          return _results;
        }).call(this);
      } catch (error) {
        return console.log("Then node %s is not in the graph", n);
      }
    };

    Graph.prototype.edges = function(nbunch, data) {
      var a, arr, b, i, j, n, nbr, nbrs, node_nbrs, seen, _ref;
      if (nbunch == null) {
        nbunch = null;
      }
      if (data == null) {
        data = false;
      }
      /*
          returns list of edges
      
          edges returns as arrays with optional data in order of [node, neighbor, data]
          nbunch = optional array of desired nodes. defaults to all nodes.
      
          the structure of node_nbrs in networkx's implementation again, poses
          weird problems with array comprehension.
      
          I will write a custom implementation.
      */

      arr = [];
      seen = {};
      if (nbunch === null) {
        node_nbrs = _items(this.adj);
      } else {
        node_nbrs = (function() {
          var _results;
          _results = [];
          for (i in nbunch) {
            n = nbunch[i];
            _results.push([n, this.adj[n]]);
          }
          return _results;
        }).call(this);
      }
      console.log('neigh!');
      console.log(node_nbrs);
      if (data) {
        for (i in node_nbrs) {
          a = node_nbrs[i];
          n = a[0];
          nbrs = a[1];
          _ref = _items(nbrs);
          for (j in _ref) {
            b = _ref[j];
            nbr = b[0];
            data = b[1];
            if (!(nbr in seen)) {
              arr.push([n, nbr, data]);
            }
          }
          seen[n] = 1;
        }
      } else {
        for (i in node_nbrs) {
          a = node_nbrs[i];
          n = a[0];
          nbrs = a[1];
          for (nbr in nbrs) {
            if (!(nbr in seen)) {
              arr.push([n, nbr]);
            }
          }
          seen[n] = 1;
        }
      }
      return arr;
    };

    Graph.prototype.degree = function(nbunch, weight) {
      var a, arr, i, n, nbr, nbrs, node_nbrs, _results, _results1;
      if (nbunch == null) {
        nbunch = null;
      }
      if (weight == null) {
        weight = null;
      }
      /*
          return the degree of a node or nodes (number of edges adjacent to the node)
          nbunch default = all nodes
      
          because iterators not supported, returns array of node-degree array pairs
      */

      arr = [];
      if (nbunch === null) {
        node_nbrs = _items(this.adj);
      } else {
        node_nbrs = (function() {
          var _results;
          _results = [];
          for (i in nbunch) {
            n = nbunch[i];
            _results.push([n, this.adj[n]]);
          }
          return _results;
        }).call(this);
      }
      if (weight === null) {
        _results = [];
        for (i in node_nbrs) {
          a = node_nbrs[i];
          n = a[0];
          nbrs = a[1];
          _results.push(arr.push([n, len(nbrs) + (n in nbrs)]));
        }
        return _results;
      } else {
        _results1 = [];
        for (i in node_nbrs) {
          a = node_nbrs[i];
          n = a[0];
          nbrs = a[1];
          _results1.push(arr.push([
            n, _sum((function() {
              var _results2;
              _results2 = [];
              for (nbr in nbrs) {
                _results2.push(nbrs[nbr][weight] || 1);
              }
              return _results2;
            })()) + (n in nbrs && nbrs[n][weight] || 1)
          ]));
        }
        return _results1;
      }
    };

    Graph.prototype.clear = function() {
      this.name = '';
      this.adj = {};
      this.node = {};
      return this.graph = {};
    };

    Graph.prototype.copy = function() {
      return clone(this);
    };

    Graph.prototype.is_multigraph = function() {
      return false;
    };

    Graph.prototype.is_directed = function() {
      return false;
    };

    Graph.prototype.to_directed = function() {
      /*
          returns a directed representation of graph
      */

      var G, data, nbrs, u, v;
      G = new GraphJS.DiGraph;
      G.name = this.name;
      g.add_nodes_from(this);
      G.add_edges_from((function() {
        var _ref, _results;
        _ref = _items(nbrs);
        _results = [];
        for (v in _ref) {
          data = _ref[v];
          _results.push((function() {
            var _ref1, _results1;
            _ref1 = _items(this.adj);
            _results1 = [];
            for (u in _ref1) {
              nbrs = _ref1[u];
              _results1.push([u, v, clone(data)]);
            }
            return _results1;
          }).call(this));
        }
        return _results;
      }).call(this));
      G.graph = clone(this.graph);
      G.node = clone(this.node);
      return G;
    };

    Graph.prototype.to_undirected = function() {
      return clone(this);
    };

    Graph.prototype.subgraph = function(nbunch) {
      /*
          return subgraph induced on nodes in nbunch
      */
      return console.log('TODO: implement this!');
    };

    Graph.prototype.nodes_with_selfloops = function() {
      /*
          return list of nodes with self loops
      */
      return console.log('TODO: implement this!');
    };

    Graph.prototype.selfloop_edges = function(data) {
      if (data == null) {
        data = false;
      }
      /*
          return a list of selfloop edges
      */

      return console.log('TODO: implement this!');
    };

    Graph.prototype.number_of_selfloops = function() {
      return console.log('TODO: Implement this!');
    };

    Graph.prototype.size = function() {
      return console.log('TODO: implement this!');
    };

    Graph.prototype.number_of_edges = function(self, u, v) {
      if (u == null) {
        u = null;
      }
      if (v == null) {
        v = null;
      }
      /*
          returns number of edges between u and v
          otherwise if not specified, returns total number of edges for all nodes
      */

      return console.log('TODO: implement this!');
    };

    Graph.prototype.add_star = function(self, nodes, attr) {
      var edges, i, n, nlist, v;
      if (attr == null) {
        attr = {};
      }
      /*
          adds a star. First node is middle of star. It is connected to all other nodes
      
          this function is currently un-tested
      */

      console.log('warning - this function has not been tested');
      nlist = _list(nodes);
      v = nlist[0];
      edges = (function() {
        var _i, _len, _ref, _results;
        _ref = nlist.slice(1);
        _results = [];
        for (n = _i = 0, _len = _ref.length; _i < _len; n = ++_i) {
          i = _ref[n];
          _results.push([v, n]);
        }
        return _results;
      })();
      return this.add_edges_from(edges, attr);
    };

    Graph.prototype.add_path = function(nodes, attr) {
      if (attr == null) {
        attr = {};
      }
      /*
          add a path.
          path constructed from nodes in order and added to the graph
      */

      return console.log('TOOD: implement this!');
    };

    Graph.prototype.add_cycle = function(nodes, attr) {
      if (attr == null) {
        attr = {};
      }
      /*
          add a cycle
      */

      return console.log('TODO: implement this!');
    };

    return Graph;

  })();

}).call(this);
